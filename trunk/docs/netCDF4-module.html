<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>netCDF4</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        Module&nbsp;netCDF4
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module netCDF4</h1><br /><br />
<h1 class="heading">Introduction</h1>
    <p>Python interface to the netCDF version 4 library.  <a 
    href="http://www.unidata.ucar.edu/software/netcdf/netcdf-4" 
    target="_top">netCDF version 4</a> has many features not found in 
    earlier versions of the library and is implemented on top of <a 
    href="http://hdf.ncsa.uiuc.edu/HDF5" target="_top">HDF5</a>. This 
    module can read files created with netCDF versions 2 and 3, but writes 
    files which are only compatible with netCDF version 4. To create files 
    which are compatible with netCDF 3 clients use the companion <a 
    href="netCDF4_classic-module.html" class="link">netCDF4_classic</a> 
    module. The API modelled after <a 
    href="http://starship.python.net/~hinsen/ScientificPython" 
    target="_top">Scientific.IO.NetCDF</a>, and should be familiar to users
    of that module.</p>
    Many new features of netCDF 4 are implemented, such as multiple 
    unlimited dimensions, groups and zlib data compression.  All the new 
    primitive data types (such as 64 bit and unsigned integer types) are 
    implemented, including variable-length strings 
    (<code>NC_STRING</code>). The <code>'vlen'</code> and 
    <code>'compound'</code> user-defined data types are supported. Vlen 
    types are variable-length, or 'ragged' arrays, while compound types are
    similar to C structs (and numpy record arrays). Compound type support 
    is not complete, since only compound types containing primitive data 
    types (and not user-defined data types) can be read or written with 
    this module.  In other words, you can't yet use this module to save 
    nested record arrays (record arrays with fields that are record 
    arrays), although you can save any record array containing fields with 
    any of the 'standard' fixed-size data types (<code>'f4', 'f8', 'i1', 
    'i2', 'i4', 'i8', 'u1', 'u2', 'u4', 'u8'</code> and 
    <code>'S1'</code>).
  <h1 class="heading">Download</h1>
    <ul>
      <li>
        <a href="http://code.google.com/p/netcdf4-python/" 
        target="_top">Project page</a>.
      </li>
      <li>
        <a href="http://code.google.com/p/netcdf4-python/source" 
        target="_top">Subversion repository</a>.
      </li>
      <li>
        <a href="http://code.google.com/p/netcdf4-python/downloads/list"
        target="_top">Source tar.gz</a>.
      </li>
    </ul>
  <h1 class="heading">Requires</h1>
    <ul>
      <li>
        Pyrex module (<a 
        href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/" 
        target="_top">http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/</a>).
        If you're using python 2.5, you'll need at least version 0.9.5.
      </li>
      <li>
        numpy array module <a href="http://numpy.scipy.org" 
        target="_top">http://numpy.scipy.org</a>, version 1.0 or later.
      </li>
      <li>
        The HDF5 C library (the latest version of version 1.8.0-beta 
        recommended), available at <a 
        href="ftp://ftp.hdfgroup.uiuc.edu/pub/outgoing/hdf5/hdf5-1.8.0-pre"
        
        target="_top">ftp://ftp.hdfgroup.uiuc.edu/pub/outgoing/hdf5/hdf5-1.8.0-pre</a>.
        Be sure to build with '<code>--enable-hl</code>'.
      </li>
      <li>
        The netCDF-4 C library (the latest version of 4.0-beta 
        recommended), available at <a 
        href="ftp://ftp.unidata.ucar.edu/pub/netcdf/netcdf-4" 
        target="_top">ftp://ftp.unidata.ucar.edu/pub/netcdf/netcdf-4</a>. 
        Be sure to build with '<code>--enable-netcdf-4</code>' and 
        '<code>--with-hdf5=$HDF5_DIR</code>', where <code>$HDF5_DIR</code> 
        is the directory where HDF5 was installed.
      </li>
    </ul>
  <h1 class="heading">Install</h1>
    <ul>
      <li>
        install the requisite python modules and C libraries (see 
        above).
      </li>
      <li>
        set the <code>HDF5_DIR</code> environment variable to point to 
        where HDF5 is installed. (the libs in <code>$HDF5_DIR/lib</code>, 
        the headers in <code>$HDF5_DIR/include</code>).
      </li>
      <li>
        set the <code>NETCDF4_DIR</code> environment variable to point 
        to where the netCDF version 4 library and headers are 
        installed.
      </li>
      <li>
        run 'python setup.py install'
      </li>
      <li>
        run some of the tests in the 'test' directory.
      </li>
    </ul>
  <h1 class="heading">Tutorial</h1>
    <h2 class="heading">1) Creating/Opening/Closing a netCDF file</h2>
      <p>To create a netCDF file from python, you simply call the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      constructor. This is also the method used to open an existing netCDF 
      file. If the file is open for write access (<code>w, r+</code> or 
      <code>a</code>), you may write any type of data including new 
      dimensions, groups, variables and attributes. netCDF files come in 
      several flavors (<code>NETCDF3_CLASSIC, NETCDF3_64BIT, 
      NETCDF4_CLASSIC</code>, and <code>NETCDF4</code>). The first two 
      flavors are supported by version 3 of the netCDF library. 
      <code>NETCDF4_CLASSIC</code> files use the version 4 disk format 
      (HDF5), but do not use any features not found in the version 3 API. 
      They can be read by netCDF 3 clients only if they have been relinked 
      against the netCDF 4 library. They can also be read by HDF5 clients. 
      <code>NETCDF4</code> files use the version 4 disk format (HDF5) and 
      use the new features of the version 4 API.  The <code>netCDF4</code> 
      module can read files with any of these formats, but only writes 
      <code>NETCDF4</code> formatted files. To write 
      <code>NETCDF4_CLASSIC</code>, <code>NETCDF3_CLASSIC</code> or 
      <code>NETCDF3_64BIT</code> formatted files, use the <a 
      href="netCDF4_classic-module.html" class="link">netCDF4_classic</a> 
      module. To see what how a given file is formatted, you can examine 
      the <code>file_format</code> <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> attribute. Closing the netCDF file is 
      accomplished via the <code>close</code> method of the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.</p>
      Here's an example:
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> netCDF4
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp = netCDF4.Dataset(<span class="py-string">'test.nc'</span>, <span class="py-string">'w'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.file_format
<span class="py-output">NETCDF4</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.close()</pre>
    <h2 class="heading">2) Groups in a netCDF file</h2>
      netCDF version 4 added support for organizing data in hierarchical
      groups, which are analagous to directories in a filesystem. Groups 
      serve as containers for variables, dimensions and attributes, as well
      as other groups.  A <code>netCDF4.Dataset</code> defines creates a 
      special group, called the 'root group', which is similar to the root 
      directory in a unix filesystem.  To create <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instances, use
      the <code>createGroup</code> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. 
      <code>createGroup</code> takes a single argument, a python string 
      containing the name of the new group. The new <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instances 
      contained within the root group can be accessed by name using the 
      <code>groups</code> dictionary attribute of the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp = netCDF4.Dataset(<span class="py-string">'test.nc'</span>, <span class="py-string">'a'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp = rootgrp.createGroup(<span class="py-string">'forecasts'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>analgrp = rootgrp.createGroup(<span class="py-string">'analyses'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.groups
<span class="py-output">{'analyses': &lt;netCDF4._Group object at 0x24a54c30&gt;, </span>
<span class="py-output"> 'forecasts': &lt;netCDF4._Group object at 0x24a54bd0&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Groups can exist within groups in a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, just as 
      directories exist within directories in a unix filesystem. Each <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance has a
      <code>'groups'</code> attribute dictionary containing all of the 
      group instances contained within that group. Each <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance also 
      has a <code>'path'</code> attribute that contains a simulated unix 
      directory path to that group.</p>
      Here's an example that shows how to navigate all the groups in a 
      <a href="netCDF4.Dataset-class.html" class="link">Dataset</a>. The 
      function <code>walktree</code> is a Python generator that is used to 
      walk the directory tree.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp1 = fcstgrp.createGroup(<span class="py-string">'model1'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp2 = fcstgrp.createGroup(<span class="py-string">'model2'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">walktree</span>(top):
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-builtin">values</span> = top.groups.values()
<span class="py-prompt">&gt;&gt;&gt; </span>    yield <span class="py-builtin">values</span>
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">for</span> value <span class="py-keyword">in</span> top.groups.values():
<span class="py-prompt">&gt;&gt;&gt; </span>        <span class="py-keyword">for</span> children <span class="py-keyword">in</span> walktree(value):
<span class="py-prompt">&gt;&gt;&gt; </span>            yield children
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.path, rootgrp
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> children <span class="py-keyword">in</span> walktree(rootgrp):
<span class="py-prompt">&gt;&gt;&gt; </span>     <span class="py-keyword">for</span> child <span class="py-keyword">in</span> children:
<span class="py-prompt">&gt;&gt;&gt; </span>         <span class="py-keyword">print</span> child.path, child
<span class="py-output">/ &lt;netCDF4.Dataset object at 0x24a54c00&gt;</span>
<span class="py-output">/analyses &lt;netCDF4.Group object at 0x24a54c30&gt;</span>
<span class="py-output">/forecasts &lt;netCDF4.Group object at 0x24a54bd0&gt;</span>
<span class="py-output">/forecasts/model2 &lt;netCDF4.Group object at 0x24a54cc0&gt;</span>
<span class="py-output">/forecasts/model1 &lt;netCDF4.Group object at 0x24a54c60&gt;</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
    <h2 class="heading">3) Dimensions in a netCDF file</h2>
      netCDF defines the sizes of all variables in terms of dimensions, 
      so before any variables can be created the dimensions they use must 
      be created first. A special case, not often used in practice, is that
      of a scalar variable, which has no dimensions. A dimension is created
      using the <code>createDimension</code> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. A 
      Python string is used to set the name of the dimension, and an 
      integer value is used to set the size. To create an unlimited 
      dimension (a dimension that can be appended to), the size value is 
      set to <code>None</code>. In this example, there both the 
      <code>time</code> and <code>level</code> dimensions are 
      unlimited.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'level'</span>, None)
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'time'</span>, None)
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'lat'</span>, 73)
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'lon'</span>, 144)</pre>
      All of the <a href="netCDF4.Dimension-class.html" 
      class="link">Dimension</a> instances are stored in a python 
      dictionary.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.dimensions
<span class="py-output">{'lat': &lt;netCDF4.Dimension object at 0x24a5f7b0&gt;, </span>
<span class="py-output"> 'time': &lt;netCDF4.Dimension object at 0x24a5f788&gt;, </span>
<span class="py-output"> 'lon': &lt;netCDF4.Dimension object at 0x24a5f7d8&gt;, </span>
<span class="py-output"> 'level': &lt;netCDF4.Dimension object at 0x24a5f760&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      Calling the python <code>len</code> function with a <a 
      href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      instance returns the current size of that dimension. The 
      <code>isunlimited()</code> method of a <a 
      href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      instance can be used to determine if the dimensions is unlimited, or 
      appendable.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> dimname, dimobj <span class="py-keyword">in</span> rootgrp.dimensions.iteritems():
<span class="py-prompt">&gt;&gt;&gt; </span>   <span class="py-keyword">print</span> dimname, len(dimobj), dimobj.isunlimited()
<span class="py-output">lat 73 False</span>
<span class="py-output">time 0 True</span>
<span class="py-output">lon 144 False</span>
<span class="py-output">level 0 True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <a href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      names can be changed using the <code>renameDimension</code> method of
      a <a href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a
      href="netCDF4.Group-class.html" class="link">Group</a> instance.
    <h2 class="heading">4) Variables in a netCDF file</h2>
      netCDF variables behave much like python multidimensional array 
      objects supplied by the <a href="http://numpy.scipy.org" 
      target="_top">numpy module</a>. However, unlike numpy arrays, netCDF4
      variables can be appended to along one or more 'unlimited' 
      dimensions. To create a netCDF variable, use the 
      <code>createVariable</code> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. The 
      <code>createVariable</code> method has two mandatory arguments, the 
      variable name (a Python string), and the variable datatype. The 
      variable's dimensions are given by a tuple containing the dimension 
      names (defined previously with <code>createDimension</code>). To 
      create a scalar variable, simply leave out the dimensions keyword. 
      The variable primitive datatypes correspond to the dtype.str 
      attribute of a numpy array, and can be one of <code>'f4'</code> 
      (32-bit floating point), <code>'f8'</code> (64-bit floating point), 
      <code>'i4'</code> (32-bit signed integer), <code>'i2'</code> (16-bit 
      signed integer), <code>'i8'</code> (64-bit singed integer), 
      <code>'i1'</code> (8-bit signed integer), <code>'u1'</code> (8-bit 
      unsigned integer), <code>'u2'</code> (16-bit unsigned integer), 
      <code>'u4'</code> (32-bit unsigned integer), <code>'u8'</code> 
      (64-bit unsigned integer), or <code>'S1'</code> (single-character 
      string). There is also a <code>'S'</code> datatype for variable 
      length strings, which have no corresponding numpy data type (they are
      stored in numpy object arrays). Variables of datatype 
      <code>'S'</code> can be used to store arbitrary python objects, since
      each element will be pickled into a string (if it is not already a 
      string) before being saved in the netCDF file (see section 9 for more
      on storing arrays of python objects). Pickle strings will be 
      automatically un-pickled back into python objects when they are read 
      back in. There is also support for netCDF user-defined datatypes, 
      such as compound data types and variable length arrays.  To create a 
      <a href="netCDF4.Variable-class.html" class="link">Variable</a> with 
      a user-defined datatype, set the datatype argument to an instance of 
      the class <a href="netCDF4.UserType-class.html" 
      class="link">UserType</a>. See section 8 for more on user-defined 
      data types. The dimensions themselves are usually also defined as 
      variables, called coordinate variables. The 
      <code>createVariable</code> method returns an instance of the <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> class 
      whose methods can be used later to access and set variable data and 
      attributes.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>times = rootgrp.createVariable(<span class="py-string">'time'</span>,<span class="py-string">'f8'</span>,(<span class="py-string">'time'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>levels = rootgrp.createVariable(<span class="py-string">'level'</span>,<span class="py-string">'i4'</span>,(<span class="py-string">'level'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes = rootgrp.createVariable(<span class="py-string">'latitude'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'lat'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes = rootgrp.createVariable(<span class="py-string">'longitude'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'lon'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># two dimensions unlimited.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>temp = rootgrp.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,))</pre>
      All of the variables in the <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> or <a href="netCDF4.Group-class.html" 
      class="link">Group</a> are stored in a Python dictionary, in the same
      way as the dimensions:
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.variables
<span class="py-output">{'temp': &lt;netCDF4.Variable object at 0x24a61068&gt;,</span>
<span class="py-output"> 'level': &lt;netCDF4.Variable object at 0.35f0f80&gt;, </span>
<span class="py-output"> 'longitude': &lt;netCDF4.Variable object at 0x24a61030&gt;,</span>
<span class="py-output"> 'pressure': &lt;netCDF4.Variable object at 0x24a610a0&gt;, </span>
<span class="py-output"> 'time': &lt;netCDF4.Variable object at 02x45f0.4.58&gt;, </span>
<span class="py-output"> 'latitude': &lt;netCDF4.Variable object at 0.3f0fb8&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <a href="netCDF4.Variable-class.html" class="link">Variable</a> 
      names can be changed using the <code>renameVariable</code> method of 
      a <a href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.
    <h2 class="heading">5) Attributes in a netCDF file</h2>
      There are two types of attributes in a netCDF file, global and 
      variable. Global attributes provide information about a group, or the
      entire dataset, as a whole. <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> attributes provide information about one of
      the variables in a group. Global attributes are set by assigning 
      values to <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> or <a href="netCDF4.Group-class.html" 
      class="link">Group</a> instance variables. <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> 
      attributes are set by assigning values to <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> 
      instances variables. Attributes can be strings, numbers or sequences.
      Returning to our example,
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> time
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.description = <span class="py-string">'bogus example script'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.history = <span class="py-string">'Created '</span> + time.ctime(time.time())
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.source = <span class="py-string">'netCDF4 python module tutorial'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes.units = <span class="py-string">'degrees north'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes.units = <span class="py-string">'degrees east'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>pressure.units = <span class="py-string">'hPa'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>temp.units = <span class="py-string">'K'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>times.units = <span class="py-string">'days since January 1, 0001'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>times.calendar = <span class="py-string">'proleptic_gregorian'</span></pre>
      The <code>ncattrs()</code> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> instance
      can be used to retrieve the names of all the netCDF attributes. This 
      method is provided as a convenience, since using the built-in 
      <code>dir</code> Python function will return a bunch of private 
      methods and attributes that cannot (or should not) be modified by the
      user.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> name <span class="py-keyword">in</span> rootgrp.ncattrs():
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">print</span> <span class="py-string">'Global attr'</span>, name, <span class="py-string">'='</span>, getattr(rootgrp,name)
<span class="py-output">Global attr description = bogus example script</span>
<span class="py-output">Global attr history = Created Mon Nov  7 10.30:56 2005</span>
<span class="py-output">Global attr source = netCDF4 python module tutorial</span></pre>
      The <code>__dict__</code> attribute of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> instance
      provides all the netCDF attribute name/value pairs in a python 
      dictionary:
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.__dict__
<span class="py-output">{'source': 'netCDF4 python module tutorial',</span>
<span class="py-output">'description': 'bogus example script',</span>
<span class="py-output">'history': 'Created Mon Nov  7 10.30:56 2005'}</span></pre>
      Attributes can be deleted from a netCDF <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> using 
      the python <code>del</code> statement (i.e. <code>del grp.foo</code> 
      removes the attribute <code>foo</code> the the group 
      <code>grp</code>).
    <h2 class="heading">6) Writing data to and retrieving data from a netCDF variable</h2>
      Now that you have a netCDF <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> instance, how do you put data into it? You 
      can just treat it like an array and assign data to a slice.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> numpy <span class="py-keyword">as</span> NP
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes[:] = NP.arange(-90,91,2.5)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'latitudes =\n'</span>,latitudes[:]
<span class="py-output">latitudes =</span>
<span class="py-output">[-90.  -87.5 -85.  -82.5 -80.  -77.5 -75.  -72.5 -70.  -67.5 -65.  -62.5</span>
<span class="py-output"> -60.  -57.5 -55.  -52.5 -50.  -47.5 -45.  -42.5 -40.  -37.5 -35.  -32.5</span>
<span class="py-output"> -30.  -27.5 -25.  -22.5 -20.  -17.5 -15.  -12.5 -10.   -7.5  -5.   -2.5</span>
<span class="py-output">   0.    2.5   5.    7.5  10.   12.5  15.   17.5  20.   22.5  25.   27.5</span>
<span class="py-output">  30.   32.5  35.   37.5  40.   42.5  45.   47.5  50.   52.5  55.   57.5</span>
<span class="py-output">  60.   62.5  65.   67.5  70.   72.5  75.   77.5  80.   82.5  85.   87.5</span>
<span class="py-output">  90. ]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      Unlike numpy array objects, netCDF <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> objects 
      with unlimited dimensions will grow along those dimensions if you 
      assign data outside the currently defined range of indices.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># append along two unlimited dimensions by assigning to slice.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nlats = len(rootgrp.dimensions[<span class="py-string">'lat'</span>])
<span class="py-prompt">&gt;&gt;&gt; </span>nlons = len(rootgrp.dimensions[<span class="py-string">'lon'</span>])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'temp shape before adding data = '</span>,temp.shape
<span class="py-output">temp shape before adding data =  (0, 0, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.random.mtrand <span class="py-keyword">import</span> uniform
<span class="py-prompt">&gt;&gt;&gt; </span>temp[0:5,0:10,:,:] = uniform(size=(5,10,nlats,nlons))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'temp shape after adding data = '</span>,temp.shape
<span class="py-output">temp shape after adding data =  (5, 10, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># levels have grown, but no values yet assigned.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'levels shape after adding pressure data = '</span>,levels.shape
<span class="py-output">levels shape after adding pressure data =  (10,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Note that the size of the levels variable grows when data is 
      appended along the <code>level</code> dimension of the variable 
      <code>temp</code>, even though no data has yet been assigned to 
      levels.</p>
      Time coordinate values pose a special challenge to netCDF users.  
      Most metadata standards (such as CF and COARDS) specify that time 
      should be measure relative to a fixed date using a certain calendar, 
      with units specified like <code>hours since YY:MM:DD hh-mm-ss</code>.
      These units can be awkward to deal with, without a utility to convert
      the values to and from calendar dates.  A module called <a 
      href="netcdftime.netcdftime-module.html" 
      class="link">netcdftime.netcdftime</a> is provided with this package 
      to do just that.  Here's an example of how it can be used:
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># fill in times.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> datetime <span class="py-keyword">import</span> datetime, timedelta
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netcdftime <span class="py-keyword">import</span> utime
<span class="py-prompt">&gt;&gt;&gt; </span>cdftime = utime(times.units,calendar=times.calendar,format=<span class="py-string">'%B %d, %Y'</span>) 
<span class="py-prompt">&gt;&gt;&gt; </span>dates = [datetime(2001,3,1)+n*timedelta(hours=12) <span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(temp.shape[0])]
<span class="py-prompt">&gt;&gt;&gt; </span>times[:] = cdftime.date2num(dates)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'time values (in units %s): '</span> % times.units+<span class="py-string">'\n'</span>,times[:]
<span class="py-output">time values (in units hours since January 1, 0001): </span>
<span class="py-output">[ 17533056.  17533068.  17533080.  17533092.  17533104.]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>dates = cdftime.num2date(times[:])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'dates corresponding to time values:\n'</span>,dates
<span class="py-output">dates corresponding to time values:</span>
<span class="py-output">[2001-03-01 00:00:00 2001-03-01 12:00:00 2001-03-02 00:00:00</span>
<span class="py-output"> 2001-03-02 12:00:00 2001-03-03 00:00:00]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      Values of time in the specified units and calendar are converted 
      to and from python <code>datetime</code> instances using the 
      <code>num2date</code> and <code>date2num</code> methods of the 
      <code>utime</code> class. See the <a 
      href="netcdftime.netcdftime-module.html" 
      class="link">netcdftime.netcdftime</a> documentation for more 
      details.
    <h2 class="heading">7) Efficient compression of netCDF variables</h2>
      <p>Data stored in netCDF <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> objects can be compressed and decompressed 
      on the fly. The parameters for the compression are determined by the 
      <code>zlib</code>, <code>complevel</code> and <code>shuffle</code> 
      keyword arguments to the <code>createVariable</code> method. To turn 
      on compression, set <code>zlib=True</code>.  The 
      <code>complevel</code> keyword regulates the speed and efficiency of 
      the compression (1 being fastest, but lowest compression ratio, 9 
      being slowest but best compression ratio). The default value of 
      <code>complevel</code> is 6. Setting <code>shuffle=False</code> will 
      turn off the HDF5 shuffle filter, which de-interlaces a block of data
      before compression by reordering the bytes. The shuffle filter can 
      significantly improve compression ratios, and is on by default.  
      Setting <code>fletcher32</code> keyword argument to 
      <code>createVariable</code> to <code>True</code> (it's 
      <code>False</code> by default) enables the Fletcher32 checksum 
      algorithm for error detection.</p>
      <p>If your data only has a certain number of digits of precision (say
      for example, it is temperature data that was measured with a 
      precision of 0.1 degrees), you can dramatically improve zlib 
      compression by quantizing (or truncating) the data using the 
      <code>least_significant_digit</code> keyword argument to 
      <code>createVariable</code>. The least significant digit is the power
      of ten of the smallest decimal place in the data that is a reliable 
      value. For example if the data has a precision of 0.1, then setting 
      <code>least_significant_digit=1</code> will cause data the data to be
      quantized using {NP.around(scale*data)/scale}, where scale = 2**bits,
      and bits is determined so that a precision of 0.1 is retained (in 
      this case bits=4). Effectively, this makes the compression 'lossy' 
      instead of 'lossless', that is some precision in the data is 
      sacrificed for the sake of disk space.</p>
      In our example, try replacing the line
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = rootgrp.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,))</pre>
      with
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = dataset.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,),zlib=True)</pre>
      and then
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = dataset.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,),zlib=True,least_significant_digit=3)</pre>
      and see how much smaller the resulting files are.
    <h2 class="heading">8) Beyond homogenous arrays of a fixed type - User-defined datatypes</h2>
      <p>User-defined data types make it easier to store data in a netCDF 4
      that does not fit well into regular arrays of data with a homogenous 
      type. NetCDF 4 supports compound types, variable length types, opaque
      types and enum types. Currently, only the variable length (or 
      <code>'vlen'</code>) type and the <code>'compound'</code> type are 
      supported.</p>
      A user-defined data type is created using the 
      <code>createUserType</code> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. This
      method returns an instance of the <a 
      href="netCDF4.UserType-class.html" class="link">UserType</a> class, 
      and takes 3 arguments; the base data type, the type of user-defined 
      data type (<code>'vlen'</code> or <code>'compound'</code>), and a 
      identification string. The base data type for a <code>'vlen'</code> 
      must be one of the fixed-size primitive data types (<code>'S'</code> 
      is not allowed). The base data type for a <code>'compound'</code> is 
      a list of 3 element tuples.  Each 3-tuple describes the type of one 
      member of the compound type, and contains a name, a fixed-size 
      primitive data type, and a shape. The <a 
      href="netCDF4.UserType-class.html" class="link">UserType</a> instance
      may then be passed to <code>createVariable</code> (instead of a 
      string describing one of the primitive data types) to create a <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> with 
      that user-defined data type. For example,
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>vleni4 = rootgrp.createUserType(<span class="py-string">'i4'</span>, <span class="py-string">'vlen'</span>, <span class="py-string">'vlen_i4'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>ragged = rootgrp.createVariable(<span class="py-string">'ragged'</span>, vleni4, (<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>))</pre>
      <p>creates a <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> which is a variable-length, or 'ragged' 
      array of 4-byte integers, with dimensions <code>lat</code> and 
      <code>lon</code>.</p>
      To fill the variable length array with data, create a numpy object
      array of integer arrays and assign it to the variable with a 
      slice.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> random
<span class="py-prompt">&gt;&gt;&gt; </span>data = NP.empty(nlats*nlons,<span class="py-string">'O'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(nlats*nlons):
<span class="py-prompt">&gt;&gt;&gt; </span>    data[n] = NP.arange(random.randint(1,10))+1
<span class="py-prompt">&gt;&gt;&gt; </span>data = NP.reshape(data,(nlats,nlons))
<span class="py-prompt">&gt;&gt;&gt; </span>ragged[:] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'ragged array variable =\n'</span>,ragged[0:3,0:3]
<span class="py-output">ragged array variable =</span>
<span class="py-output">[[[1] [1 2 3 4 5 6 7] [1 2]]</span>
<span class="py-output"> [[1 2 3 4] [1 2 3 4 5 6 7 8] [1]]</span>
<span class="py-output"> [[1 2 3 4 5 6 7] [1 2 3] [1 2 3 4 5 6 7]]]</span></pre>
      Compound types are similar to C structs. They can be used to 
      represent table-like structures composed of different primitive data 
      types (the netCDF4 library supports nested compound types, but this 
      module only supports fixed-size primitive data types within compound 
      types).  For example, compound types might be useful for representing
      multiple parameter values at each point on a grid, or at each time 
      and space location for scattered (point) data. You can then access 
      all the information for a point by reading one variable, instead of 
      reading different parameters from different variables. Variables of 
      compound type correspond directly to numpy record arrays. Here's a 
      simple example using a compound type to represent meteorological 
      observations at stations:
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create an unlimited  dimension call 'station'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'station'</span>,False)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># define a compound data type (a list of 3-tuples containing</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># the name of each member, it's primitive data type, and it's size).</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Only fixed-size primitive data types allowed (no 'S').</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Members can be multi-dimensional arrays (in which case the third</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># element is a shape tuple instead of a scalar).</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datatype = [(<span class="py-string">'latitude'</span>, <span class="py-string">'f4'</span>,1), (<span class="py-string">'longitude'</span>, <span class="py-string">'f4'</span>,1),
<span class="py-prompt">&gt;&gt;&gt; </span>            (<span class="py-string">'sfc_press'</span>,<span class="py-string">'i4'</span>,1),
<span class="py-prompt">&gt;&gt;&gt; </span>            (<span class="py-string">'temp_sounding'</span>,<span class="py-string">'f4'</span>,10),(<span class="py-string">'press_sounding'</span>,<span class="py-string">'i4'</span>,10),
<span class="py-prompt">&gt;&gt;&gt; </span>            (<span class="py-string">'location_name'</span>,<span class="py-string">'S1'</span>,80)]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># use this data type definition to create a user-defined data type</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># called 'station_data'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>table = rootgrp.createUserType(datatype,<span class="py-string">'compound'</span>,<span class="py-string">'station_data'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create a variable of of type 'station_data'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat = rootgrp.createVariable(<span class="py-string">'station_obs'</span>, table, (<span class="py-string">'station'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create record array, assign data to it.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>ra = NP.empty(1,statdat.dtype_base)
<span class="py-prompt">&gt;&gt;&gt; </span>ra[<span class="py-string">'latitude'</span>] = 40.
<span class="py-prompt">&gt;&gt;&gt; </span>ra[<span class="py-string">'longitude'</span>] = -105.
<span class="py-prompt">&gt;&gt;&gt; </span>ra[<span class="py-string">'sfc_press'</span>] = 818
<span class="py-prompt">&gt;&gt;&gt; </span>ra[<span class="py-string">'temp_sounding'</span>] = (280.3,272.,270.,269.,266.,258.,254.1,250.,245.5,240.)
<span class="py-prompt">&gt;&gt;&gt; </span>ra[<span class="py-string">'press_sounding'</span>] = range(800,300,-50)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># only fixed-size primitive data types can currenlty be used</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># as compound data type members (although the library supports</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># nested compound types).</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># To store strings in a compound data type, each string must be </span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># stored as fixed-size (in this case 80) array of characters.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">stringtoarr</span>(string,NUMCHARS):
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-comment"># function to convert a string to a array of NUMCHARS characters</span>
<span class="py-prompt">&gt;&gt;&gt; </span>    arr = NP.zeros(NUMCHARS,<span class="py-string">'S1'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>    arr[0:len(string)] = tuple(string)
<span class="py-prompt">&gt;&gt;&gt; </span>    return arr
<span class="py-prompt">&gt;&gt;&gt; </span>ra[<span class="py-string">'location_name'</span>] = stringtoarr(<span class="py-string">'Boulder, Colorado, USA'</span>,80)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># assign record array to variable slice.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat[0] = ra
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># or just assign a tuple of values to variable slice</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># (will automatically be converted to a record array).</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat[1] = (40.78,-73.99,1002,
<span class="py-prompt">&gt;&gt;&gt; </span>            (290.2,282.5,279.,277.9,276.,266.,264.1,260.,255.5,243.),
<span class="py-prompt">&gt;&gt;&gt; </span>            range(900,400,-50),stringtoarr(<span class="py-string">'New York, New York, USA'</span>,80))</pre>
      This module doesn't support attributes of compound type. To assign
      an attribute like <code>units</code> to each member of the compound 
      type I do the following:
      <ul>
        <li>
          create a python dict with key/value pairs representing the 
          name of each compound type member and it's units.
        </li>
        <li>
          convert the dict to a string using the repr function.
        </li>
        <li>
          use that string as a variable attribute.
        </li>
      </ul>
      When this attribute is read in it can be converted back to a 
      python dictionary using the <code>eval</code> function. It can be 
      converted into hash-like objects in other languages as well 
      (including C), since this string is also valid JSON (<a 
      href="http://json.org" target="_top">JavaScript Object Notation</a>).
      JSON is a lightweight, language-independent data serialization 
      format.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>units_dict = {<span class="py-string">'latitude'</span>: <span class="py-string">'degrees north'</span>, <span class="py-string">'longitude'</span>: <span class="py-string">'degrees east'</span>,
<span class="py-output">                  'sfc_press': 'Pascals', 'temp_sounding': 'Kelvin',</span>
<span class="py-output">                  'press_sounding': 'Pascals','location_name': None}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>statdat.units = repr(units_dict)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># convert units string back to a python dictionary.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat_units = eval(statdat.units)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># print out data in variable (including units attribute)</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'data in a variable of compound type:\n----'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> data <span class="py-keyword">in</span> statdat[:]:
<span class="py-prompt">&gt;&gt;&gt; </span>   <span class="py-keyword">for</span> item <span class="py-keyword">in</span> statdat.dtype_base:
<span class="py-prompt">&gt;&gt;&gt; </span>       name = item[0]
<span class="py-prompt">&gt;&gt;&gt; </span>       type = item[1]
<span class="py-prompt">&gt;&gt;&gt; </span>       <span class="py-keyword">if</span> type == <span class="py-string">'S1'</span>: <span class="py-comment"># if array of chars, convert value to string.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>           <span class="py-keyword">print</span> name,<span class="py-string">': value ='</span>,data[name].tostring(),<span class="py-string">'units ='</span>,statdat_units[name]
<span class="py-prompt">&gt;&gt;&gt; </span>       <span class="py-keyword">else</span>:
<span class="py-prompt">&gt;&gt;&gt; </span>           <span class="py-keyword">print</span> name,<span class="py-string">': value ='</span>,data[name],<span class="py-string">'units ='</span>,statdat_units[name]
<span class="py-prompt">&gt;&gt;&gt; </span>   <span class="py-keyword">print</span> <span class="py-string">'----'</span>
<span class="py-output">----</span>
<span class="py-output">data in a variable of compound type:</span>
<span class="py-output">latitude : value = 40.0 units = degrees north</span>
<span class="py-output">longitude : value = -105.0 units = degrees east</span>
<span class="py-output">sfc_press : value = 818 units = Pascals</span>
<span class="py-output">temp_sounding : value = [ 280.29998779  272.          270.          269.          266.</span>
<span class="py-output">  258.   254.1000061   250.          245.5         240.        ] units = Kelvin</span>
<span class="py-output">press_sounding : value = [800 750 700 650 600 550 500 450 400 350] units = Pascals</span>
<span class="py-output">location_name : value = Boulder, Colorado, USA units = None</span>
<span class="py-output">----</span>
<span class="py-output">latitude : value = 40.7799987793 units = degrees north</span>
<span class="py-output">longitude : value = -73.9899978638 units = degrees east</span>
<span class="py-output">sfc_press : value = 1002 units = Pascals</span>
<span class="py-output">temp_sounding : value = [ 290.20001221  282.5         279.          277.8999939   276.  </span>
<span class="py-output">  266.   264.1000061   260.          255.5         243.        ] units = Kelvin</span>
<span class="py-output">press_sounding : value = [900 850 800 750 700 650 600 550 500 450] units = Pascals</span>
<span class="py-output">location_name : value = New York, New York, USA units = None</span>
<span class="py-output">----</span></pre>
    <h2 class="heading">9) Storing arrays of arbitrary python objects using the 'S' datatype</h2>
      Variables with datatype <code>'S'</code> can be used to store 
      variable-length strings, or python objects.  Here's an example.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>strvar = rootgrp.createVariable(<span class="py-string">'strvar'</span>,<span class="py-string">'S'</span>,(<span class="py-string">'level'</span>))</pre>
      Typically, a string variable is used to hold variable-length 
      strings. They are represented in python as numpy object arrays 
      containing python strings. Below an object array is filled with 
      random python strings with random lengths between 2 and 12 
      characters.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>chars = <span class="py-string">'1234567890aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>data = NP.empty(10,<span class="py-string">'O'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(10):
<span class="py-prompt">&gt;&gt;&gt; </span>    stringlen = random.randint(2,12)
<span class="py-prompt">&gt;&gt;&gt; </span>    data[n] = <span class="py-string">''</span>.join([random.choice(chars) <span class="py-keyword">for</span> i <span class="py-keyword">in</span> range(stringlen)])</pre>
      Now, we replace the first element of the object array with a 
      python dictionary.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>data[0] = {<span class="py-string">'spam'</span>:1,<span class="py-string">'eggs'</span>:2,<span class="py-string">'ham'</span>:False}</pre>
      When the data is assigned to the string variable, elements which 
      are not python strings are converted to strings using the python 
      <code>cPickle</code> module.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>strvar[:] = data</pre>
      When the data is read back in from the netCDF file, strings which 
      are determined to be pickled python objects are unpickled back into 
      objects.
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'string variable with embedded python objects:\n'</span>,strvar[:]
<span class="py-output">string variable with embedded python objects:</span>
<span class="py-output">[{'eggs': 2, 'ham': False, 'spam': 1} QnXTY8B nbt4zisk pMHIn1F wl3suHW0OquZ</span>
<span class="py-output"> wn5kxEzgE nk AGBL pe kay81]</span></pre>
      Attributes can also be python objects, although the rules for 
      whether they are saved as pickled strings are different.  Attributes 
      are converted to numpy arrays before being saved to the netCDF file.
      If the attribute is cast to an object array by numpy, it is pickled 
      and saved as a text attribute (and then automatically unpickled when 
      the attribute is accessed).  So, an attribute which is a list of 
      integers will be saved as an array of integers, while an attribute 
      that is a python dictionary will be saved as a pickled string, then 
      unpickled automatically when it is retrieved. For example,
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> datetime <span class="py-keyword">import</span> datetime
<span class="py-prompt">&gt;&gt;&gt; </span>strvar.timestamp = datetime.now()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> strvar.timestamp
<span class="py-output">2006-02-11 13:26:27.238042</span></pre>
      <p>Note that data saved as pickled strings will not be very useful if
      the data is to be read by a non-python client (the data will appear 
      to the client as an ugly looking binary string). A more portable (and
      human-readable) way of saving simple data structures like 
      dictionaries and lists is to serialize them into strings using a 
      human-readable cross-language interchange format such as <a 
      href="http://json.org" target="_top">JSON</a> or <a 
      href="http://yaml.org" target="_top">YAML</a>.  An example of this is
      given in the discussion of compound data types in section 8.</p>
      All of the code in this tutorial is available in 
      examples/tutorial.py, along with several other examples. Unit tests 
      are in the test directory.<br /><br />

<hr />
<div class="fields">      <p><strong>Contact:</strong>
        Jeffrey Whitaker &lt;jeffrey.s.whitaker@noaa.gov&gt;
      </p>
      <p><strong>Copyright:</strong>
        2006 by Jeffrey Whitaker.
      </p>
      <p><strong>License:</strong>
        Permission to use, copy, modify, and distribute this software 
        and its documentation for any purpose and without fee is hereby 
        granted, provided that the above copyright notice appear in all 
        copies and that both the copyright notice and this permission 
        notice appear in supporting documentation. THE AUTHOR DISCLAIMS ALL
        WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED 
        WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE 
        AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
        OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR 
        PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER 
        TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
        PERFORMANCE OF THIS SOFTWARE.
      </p>
      <p><strong>Version:</strong>
        0.6.3
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Classes</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Dataset-class.html" class="summary-name">Dataset</a><br />
      A netCDF <a href="netCDF4.Dataset-class.html" 
        class="link">Dataset</a> is a collection of dimensions, groups, 
        variables and attributes.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Dimension-class.html" class="summary-name">Dimension</a><br />
      A netCDF <a href="netCDF4.Dimension-class.html" 
        class="link">Dimension</a> is used to describe the coordinates of a
        <a href="netCDF4.Variable-class.html" 
        class="link">Variable</a>.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Group-class.html" class="summary-name">Group</a><br />
      Groups define a hierarchical namespace within a netCDF file.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.UserType-class.html" class="summary-name">UserType</a><br />
      A <a href="netCDF4.UserType-class.html" 
        class="link">UserType</a> instance is used to describe some of the 
        new data types supported in netCDF 4.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Variable-class.html" class="summary-name">Variable</a><br />
      A netCDF <a href="netCDF4.Variable-class.html" 
        class="link">Variable</a> is used to read and write netCDF 
        data.
    </td>
  </tr>
</table>
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0beta1 on Thu Jul 12 16:11:43 2007
    </td>
    <td align="right" class="footer">
      <a href="http://epydoc.sourceforge.net">http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie()
  // -->
</script>
  
</body>
</html>
